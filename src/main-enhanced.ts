import Phaser from 'phaser';
import { AdvancedAIPlayer, Player, BoardState, AIMove } from './systems/AdvancedAI';
import { GameFeelManager } from './systems/GameFeel';
import { TournamentSystem, TournamentPlayer, Tournament } from './systems/TournamentSystem';
import { PerformanceMonitor } from './systems/PerformanceMonitor';

const WIDTH = 800;
const HEIGHT = 700;

/**
 * Enhanced Tic-Tac-Toe with Advanced AI, Tournament System, and Cutting-Edge Game Feel
 */
class EnhancedTicTacToeScene extends Phaser.Scene {
  // Game state
  private board: BoardState = [
    [null, null, null],
    [null, null, null],
    [null, null, null]
  ];
  private currentPlayer: Player = 'X';
  private gameOver = false;
  private gameMode: 'PvP' | 'PvAI' | 'AIvAI' | 'Tournament' = 'PvAI';
  
  // Game settings
  private cellSize = 140;
  private boardStartX = 0;
  private boardStartY = 0;
  
  // Advanced systems
  private gameFeelManager!: GameFeelManager;
  private aiPlayer!: AdvancedAIPlayer;
  private tournamentSystem!: TournamentSystem;
  private performanceMonitor!: PerformanceMonitor;
  
  // Visual elements
  private boardGraphics!: Phaser.GameObjects.Graphics;
  private cellHighlights: Phaser.GameObjects.Rectangle[] = [];
  private markTexts: Phaser.GameObjects.Text[][] = [];
  private uiElements: { [key: string]: Phaser.GameObjects.GameObject } = {};
  private thinkingIndicator?: Phaser.GameObjects.Container;
  
  // UI State
  private showPerformanceMetrics = false;
  private currentTournament?: Tournament;
  private scores = { X: 0, O: 0, draws: 0 };
  private aiDifficulty: 'Easy' | 'Medium' | 'Hard' | 'Expert' | 'Impossible' = 'Hard';
  
  // Animation and timing
  private isProcessingMove = false;
  private moveHistory: { player: Player; position: { row: number; col: number }; timestamp: Date }[] = [];
  
  init() {
    this.boardStartX = (WIDTH - this.cellSize * 3) / 2;
    this.boardStartY = 150;
  }
  
  create() {
    this.initializeSystems();
    this.setupVisuals();
    this.setupUI();
    this.setupInput();
    this.newGame();
  }
  
  private initializeSystems(): void {
    // Initialize advanced systems
    this.gameFeelManager = new GameFeelManager(this);
    this.aiPlayer = new AdvancedAIPlayer('O', this.aiDifficulty);
    this.tournamentSystem = new TournamentSystem();
    this.performanceMonitor = new PerformanceMonitor();
    
    // Setup performance monitoring
    this.performanceMonitor.addListener((metrics) => {
      this.updatePerformanceDisplay(metrics);
    });
  }
  
  private setupVisuals(): void {
    this.cameras.main.setBackgroundColor('#1a1a2e');
    
    // Create graphics objects
    this.boardGraphics = this.add.graphics();
    
    // Initialize mark text array
    for (let row = 0; row < 3; row++) {
      this.markTexts[row] = [];
      for (let col = 0; col < 3; col++) {
        this.markTexts[row][col] = this.add.text(0, 0, '', {
          fontSize: '64px',
          color: '#ffffff'
        }).setOrigin(0.5).setVisible(false);
      }
    }
  }
  
  private setupUI(): void {
    // Title
    this.uiElements.title = this.add.text(WIDTH / 2, 30, 'Enhanced Tic-Tac-Toe', {
      fontSize: '28px',
      color: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0.5);\n    \n    // Current player indicator\n    this.uiElements.currentPlayerText = this.add.text(WIDTH / 2, 70, '', {\n      fontSize: '20px',\n      color: '#fbbf24'\n    }).setOrigin(0.5);\n    \n    // Game mode selector\n    this.createGameModeSelector();\n    \n    // AI difficulty selector\n    this.createAIDifficultySelector();\n    \n    // Score display\n    this.createScoreDisplay();\n    \n    // Performance metrics (hidden by default)\n    this.uiElements.performanceText = this.add.text(WIDTH - 10, 10, '', {\n      fontSize: '10px',\n      color: '#888888'\n    }).setOrigin(1, 0).setVisible(false);\n    \n    // Control instructions\n    this.uiElements.instructions = this.add.text(WIDTH / 2, HEIGHT - 30, 'Click cells to play | P: Performance | N: New Game | T: Tournament', {\n      fontSize: '12px',\n      color: '#666666'\n    }).setOrigin(0.5);\n  }\n  \n  private createGameModeSelector(): void {\n    const modes = ['PvP', 'PvAI', 'AIvAI', 'Tournament'];\n    const startX = 50;\n    const y = 110;\n    \n    modes.forEach((mode, index) => {\n      const button = this.add.rectangle(\n        startX + index * 80, y, 70, 30,\n        mode === this.gameMode ? 0x4ecdc4 : 0x333333\n      ).setStrokeStyle(1, 0x666666);\n      \n      const text = this.add.text(startX + index * 80, y, mode, {\n        fontSize: '12px',\n        color: '#ffffff'\n      }).setOrigin(0.5);\n      \n      button.setInteractive({ useHandCursor: true })\n        .on('pointerdown', () => this.setGameMode(mode as any))\n        .on('pointerover', () => this.gameFeelManager.hoverEffect(button, 1.1))\n        .on('pointerout', () => this.gameFeelManager.unhoverEffect(button));\n      \n      this.uiElements[`mode_${mode}`] = button;\n      this.uiElements[`modeText_${mode}`] = text;\n    });\n  }\n  \n  private createAIDifficultySelector(): void {\n    const difficulties: Array<'Easy' | 'Medium' | 'Hard' | 'Expert' | 'Impossible'> = \n      ['Easy', 'Medium', 'Hard', 'Expert', 'Impossible'];\n    const startX = 450;\n    const y = 110;\n    \n    difficulties.forEach((diff, index) => {\n      const button = this.add.rectangle(\n        startX + index * 60, y, 55, 25,\n        diff === this.aiDifficulty ? 0xff6b6b : 0x333333\n      ).setStrokeStyle(1, 0x666666);\n      \n      const text = this.add.text(startX + index * 60, y, diff, {\n        fontSize: '10px',\n        color: '#ffffff'\n      }).setOrigin(0.5);\n      \n      button.setInteractive({ useHandCursor: true })\n        .on('pointerdown', () => this.setAIDifficulty(diff))\n        .on('pointerover', () => this.gameFeelManager.hoverEffect(button, 1.1))\n        .on('pointerout', () => this.gameFeelManager.unhoverEffect(button));\n      \n      this.uiElements[`diff_${diff}`] = button;\n      this.uiElements[`diffText_${diff}`] = text;\n    });\n  }\n  \n  private createScoreDisplay(): void {\n    const y = HEIGHT - 80;\n    \n    // Score background\n    this.uiElements.scoreBG = this.add.rectangle(WIDTH / 2, y, 300, 40, 0x333333, 0.8)\n      .setStrokeStyle(1, 0x666666);\n    \n    // Score texts\n    this.uiElements.scoreX = this.add.text(WIDTH / 2 - 80, y, 'X: 0', {\n      fontSize: '16px',\n      color: '#ff6b6b',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n    \n    this.uiElements.scoreO = this.add.text(WIDTH / 2, y, 'O: 0', {\n      fontSize: '16px',\n      color: '#4ecdc4',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n    \n    this.uiElements.scoreDraw = this.add.text(WIDTH / 2 + 80, y, 'Draws: 0', {\n      fontSize: '16px',\n      color: '#fbbf24',\n      fontStyle: 'bold'\n    }).setOrigin(0.5);\n  }\n  \n  private setupInput(): void {\n    // Board click handler\n    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {\n      if (!this.isProcessingMove) {\n        this.handleBoardClick(pointer.x, pointer.y);\n      }\n    });\n    \n    // Keyboard controls\n    this.input.keyboard.on('keydown-P', () => {\n      this.showPerformanceMetrics = !this.showPerformanceMetrics;\n      (this.uiElements.performanceText as Phaser.GameObjects.Text).setVisible(this.showPerformanceMetrics);\n    });\n    \n    this.input.keyboard.on('keydown-N', () => {\n      this.newGame();\n    });\n    \n    this.input.keyboard.on('keydown-T', () => {\n      this.startTournamentMode();\n    });\n    \n    // Hover effects for board cells\n    this.setupBoardHoverEffects();\n  }\n  \n  private setupBoardHoverEffects(): void {\n    // Create invisible interactive areas for each cell\n    for (let row = 0; row < 3; row++) {\n      for (let col = 0; col < 3; col++) {\n        const cellX = this.boardStartX + col * this.cellSize + this.cellSize / 2;\n        const cellY = this.boardStartY + row * this.cellSize + this.cellSize / 2;\n        \n        const cellArea = this.add.rectangle(cellX, cellY, this.cellSize, this.cellSize, 0x000000, 0)\n          .setInteractive({ useHandCursor: true });\n        \n        cellArea.on('pointerover', () => {\n          if (!this.gameOver && this.board[row][col] === null && !this.isProcessingMove) {\n            if (this.gameMode === 'PvP' || \n                (this.gameMode === 'PvAI' && this.currentPlayer === 'X')) {\n              this.highlightCell(row, col, true);\n            }\n          }\n        });\n        \n        cellArea.on('pointerout', () => {\n          this.highlightCell(row, col, false);\n        });\n      }\n    }\n  }\n  \n  update(): void {\n    this.performanceMonitor.update();\n    \n    // Handle AI moves\n    if (!this.gameOver && !this.isProcessingMove) {\n      if ((this.gameMode === 'PvAI' && this.currentPlayer === 'O') ||\n          this.gameMode === 'AIvAI') {\n        this.handleAIMove();\n      }\n    }\n    \n    // Performance tracking\n    this.performanceMonitor.setCustomMetric('gameMode', this.gameMode === 'Tournament' ? 1 : 0);\n    this.performanceMonitor.setCustomMetric('aiDifficulty', this.getDifficultyValue());\n    this.performanceMonitor.trackRenderCall();\n    this.performanceMonitor.resetFrame();\n  }\n  \n  private handleBoardClick(x: number, y: number): void {\n    if (this.gameOver || this.isProcessingMove) return;\n    \n    const col = Math.floor((x - this.boardStartX) / this.cellSize);\n    const row = Math.floor((y - this.boardStartY) / this.cellSize);\n    \n    if (row >= 0 && row < 3 && col >= 0 && col < 3 && this.board[row][col] === null) {\n      // Only allow human moves in appropriate game modes\n      if (this.gameMode === 'PvP' || \n          (this.gameMode === 'PvAI' && this.currentPlayer === 'X')) {\n        this.makeMove(row, col, this.currentPlayer);\n      }\n    }\n  }\n  \n  private async handleAIMove(): Promise<void> {\n    if (this.isProcessingMove) return;\n    \n    this.isProcessingMove = true;\n    \n    // Show thinking indicator\n    const cellX = WIDTH / 2;\n    const cellY = this.boardStartY - 30;\n    this.thinkingIndicator = this.gameFeelManager.createThinkingIndicator(cellX, cellY);\n    \n    // Add realistic thinking delay based on difficulty\n    const thinkingTime = this.getAIThinkingTime();\n    \n    await new Promise(resolve => {\n      this.time.delayedCall(thinkingTime, resolve);\n    });\n    \n    // Remove thinking indicator\n    if (this.thinkingIndicator) {\n      this.thinkingIndicator.destroy();\n      this.thinkingIndicator = undefined;\n    }\n    \n    try {\n      const aiMove = this.aiPlayer.getBestMove(this.board);\n      \n      // Show AI analysis (if performance metrics are enabled)\n      if (this.showPerformanceMetrics) {\n        console.log('AI Analysis:', aiMove);\n      }\n      \n      await this.makeMove(aiMove.position.row, aiMove.position.col, this.currentPlayer);\n    } catch (error) {\n      console.error('AI Move Error:', error);\n    }\n    \n    this.isProcessingMove = false;\n  }\n  \n  private getAIThinkingTime(): number {\n    switch (this.aiDifficulty) {\n      case 'Easy': return 200;\n      case 'Medium': return 500;\n      case 'Hard': return 800;\n      case 'Expert': return 1200;\n      case 'Impossible': return 1500;\n      default: return 500;\n    }\n  }\n  \n  private async makeMove(row: number, col: number, player: Player): Promise<void> {\n    if (this.board[row][col] !== null) return;\n    \n    this.board[row][col] = player;\n    \n    // Record move\n    this.moveHistory.push({\n      player,\n      position: { row, col },\n      timestamp: new Date()\n    });\n    \n    // Visual feedback\n    await this.animateMarkPlacement(row, col, player);\n    \n    // Check game end conditions\n    if (this.checkWin(player)) {\n      await this.handleWin(player);\n    } else if (this.checkDraw()) {\n      await this.handleDraw();\n    } else {\n      this.switchPlayer();\n    }\n  }\n  \n  private async animateMarkPlacement(row: number, col: number, player: Player): Promise<void> {\n    const cellX = this.boardStartX + col * this.cellSize + this.cellSize / 2;\n    const cellY = this.boardStartY + row * this.cellSize + this.cellSize / 2;\n    \n    const color = player === 'X' ? 0xff6b6b : 0x4ecdc4;\n    \n    // Enhanced mark placement with game feel\n    const markText = await this.gameFeelManager.placeMark(cellX, cellY, player, color, 64);\n    this.markTexts[row][col] = markText;\n    \n    // Subtle screen shake\n    this.gameFeelManager.screenShake(3, 80);\n  }\n  \n  private async handleWin(winner: Player): Promise<void> {\n    this.gameOver = true;\n    \n    // Update scores\n    this.scores[winner]++;\n    this.updateScoreDisplay();\n    \n    // Find winning line and animate it\n    const winningLine = this.getWinningLine(winner);\n    if (winningLine) {\n      this.animateWinningLine(winningLine);\n    }\n    \n    // Victory effects\n    const color = winner === 'X' ? 0xff6b6b : 0x4ecdc4;\n    this.gameFeelManager.victoryEffect(winner, color);\n    \n    // Show win message\n    await this.showWinMessage(winner);\n    \n    // Auto-restart after delay\n    this.time.delayedCall(2000, () => {\n      if (this.gameMode !== 'Tournament') {\n        this.newGame();\n      } else {\n        this.handleTournamentResult(winner);\n      }\n    });\n  }\n  \n  private async handleDraw(): Promise<void> {\n    this.gameOver = true;\n    \n    // Update scores\n    this.scores.draws++;\n    this.updateScoreDisplay();\n    \n    // Draw effects\n    this.gameFeelManager.drawEffect();\n    \n    // Show draw message\n    await this.showDrawMessage();\n    \n    // Auto-restart after delay\n    this.time.delayedCall(1500, () => {\n      if (this.gameMode !== 'Tournament') {\n        this.newGame();\n      } else {\n        this.handleTournamentResult('Draw');\n      }\n    });\n  }\n  \n  private switchPlayer(): void {\n    this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';\n    this.updateUI();\n    \n    // Update AI player if needed\n    if (this.gameMode === 'AIvAI') {\n      this.aiPlayer = new AdvancedAIPlayer(this.currentPlayer, this.aiDifficulty);\n    }\n  }\n  \n  private drawBoard(): void {\n    this.boardGraphics.clear();\n    \n    // Draw grid lines with enhanced styling\n    this.boardGraphics.lineStyle(4, 0xffffff, 0.8);\n    \n    // Vertical lines\n    for (let i = 1; i < 3; i++) {\n      const x = this.boardStartX + i * this.cellSize;\n      this.boardGraphics.lineBetween(x, this.boardStartY, x, this.boardStartY + this.cellSize * 3);\n    }\n    \n    // Horizontal lines\n    for (let i = 1; i < 3; i++) {\n      const y = this.boardStartY + i * this.cellSize;\n      this.boardGraphics.lineBetween(this.boardStartX, y, this.boardStartX + this.cellSize * 3, y);\n    }\n    \n    // Draw border\n    this.boardGraphics.strokeRoundedRect(\n      this.boardStartX - 5, \n      this.boardStartY - 5, \n      this.cellSize * 3 + 10, \n      this.cellSize * 3 + 10, \n      10\n    );\n  }\n  \n  private highlightCell(row: number, col: number, show: boolean): void {\n    const index = row * 3 + col;\n    \n    if (show && !this.cellHighlights[index]) {\n      const cellX = this.boardStartX + col * this.cellSize + this.cellSize / 2;\n      const cellY = this.boardStartY + row * this.cellSize + this.cellSize / 2;\n      \n      this.cellHighlights[index] = this.gameFeelManager.highlightCell(\n        cellX, cellY, this.cellSize, 0xffffff, 0.1\n      );\n    } else if (!show && this.cellHighlights[index]) {\n      this.cellHighlights[index].destroy();\n      this.cellHighlights[index] = null as any;\n    }\n  }\n  \n  private checkWin(player: Player): boolean {\n    // Check rows\n    for (let row = 0; row < 3; row++) {\n      if (this.board[row].every(cell => cell === player)) {\n        return true;\n      }\n    }\n    \n    // Check columns\n    for (let col = 0; col < 3; col++) {\n      if (this.board.every(row => row[col] === player)) {\n        return true;\n      }\n    }\n    \n    // Check diagonals\n    if (this.board[0][0] === player && this.board[1][1] === player && this.board[2][2] === player) {\n      return true;\n    }\n    \n    if (this.board[0][2] === player && this.board[1][1] === player && this.board[2][0] === player) {\n      return true;\n    }\n    \n    return false;\n  }\n  \n  private checkDraw(): boolean {\n    return this.board.flat().every(cell => cell !== null);\n  }\n  \n  private getWinningLine(player: Player): { start: { x: number; y: number }; end: { x: number; y: number } } | null {\n    // Check rows\n    for (let row = 0; row < 3; row++) {\n      if (this.board[row].every(cell => cell === player)) {\n        return {\n          start: { \n            x: this.boardStartX + this.cellSize / 2, \n            y: this.boardStartY + row * this.cellSize + this.cellSize / 2 \n          },\n          end: { \n            x: this.boardStartX + 2.5 * this.cellSize, \n            y: this.boardStartY + row * this.cellSize + this.cellSize / 2 \n          }\n        };\n      }\n    }\n    \n    // Check columns\n    for (let col = 0; col < 3; col++) {\n      if (this.board.every(row => row[col] === player)) {\n        return {\n          start: { \n            x: this.boardStartX + col * this.cellSize + this.cellSize / 2, \n            y: this.boardStartY + this.cellSize / 2 \n          },\n          end: { \n            x: this.boardStartX + col * this.cellSize + this.cellSize / 2, \n            y: this.boardStartY + 2.5 * this.cellSize \n          }\n        };\n      }\n    }\n    \n    // Check diagonals\n    if (this.board[0][0] === player && this.board[1][1] === player && this.board[2][2] === player) {\n      return {\n        start: { x: this.boardStartX + this.cellSize / 2, y: this.boardStartY + this.cellSize / 2 },\n        end: { x: this.boardStartX + 2.5 * this.cellSize, y: this.boardStartY + 2.5 * this.cellSize }\n      };\n    }\n    \n    if (this.board[0][2] === player && this.board[1][1] === player && this.board[2][0] === player) {\n      return {\n        start: { x: this.boardStartX + 2.5 * this.cellSize, y: this.boardStartY + this.cellSize / 2 },\n        end: { x: this.boardStartX + this.cellSize / 2, y: this.boardStartY + 2.5 * this.cellSize }\n      };\n    }\n    \n    return null;\n  }\n  \n  private animateWinningLine(line: { start: { x: number; y: number }; end: { x: number; y: number } }): void {\n    const color = this.currentPlayer === 'X' ? 0xff6b6b : 0x4ecdc4;\n    this.gameFeelManager.animateWinningLine(line.start.x, line.start.y, line.end.x, line.end.y, color);\n  }\n  \n  private async showWinMessage(winner: Player): Promise<void> {\n    const color = winner === 'X' ? '#ff6b6b' : '#4ecdc4';\n    const message = this.add.text(WIDTH / 2, HEIGHT / 2 - 50, `Player ${winner} Wins!`, {\n      fontSize: '36px',\n      color,\n      fontStyle: 'bold'\n    }).setOrigin(0.5).setAlpha(0);\n    \n    // Animate message appearance\n    this.tweens.add({\n      targets: message,\n      alpha: 1,\n      scale: { from: 0.5, to: 1 },\n      duration: 500,\n      ease: 'Back.easeOut'\n    });\n  }\n  \n  private async showDrawMessage(): Promise<void> {\n    const message = this.add.text(WIDTH / 2, HEIGHT / 2 - 50, \"It's a Draw!\", {\n      fontSize: '36px',\n      color: '#fbbf24',\n      fontStyle: 'bold'\n    }).setOrigin(0.5).setAlpha(0);\n    \n    // Animate message appearance\n    this.tweens.add({\n      targets: message,\n      alpha: 1,\n      scale: { from: 0.5, to: 1 },\n      duration: 500,\n      ease: 'Back.easeOut'\n    });\n  }\n  \n  private setGameMode(mode: 'PvP' | 'PvAI' | 'AIvAI' | 'Tournament'): void {\n    this.gameMode = mode;\n    this.updateGameModeButtons();\n    this.newGame();\n  }\n  \n  private setAIDifficulty(difficulty: 'Easy' | 'Medium' | 'Hard' | 'Expert' | 'Impossible'): void {\n    this.aiDifficulty = difficulty;\n    this.aiPlayer.setDifficulty(difficulty);\n    this.updateAIDifficultyButtons();\n  }\n  \n  private updateGameModeButtons(): void {\n    const modes = ['PvP', 'PvAI', 'AIvAI', 'Tournament'];\n    modes.forEach(mode => {\n      const button = this.uiElements[`mode_${mode}`] as Phaser.GameObjects.Rectangle;\n      button.setFillStyle(mode === this.gameMode ? 0x4ecdc4 : 0x333333);\n    });\n  }\n  \n  private updateAIDifficultyButtons(): void {\n    const difficulties = ['Easy', 'Medium', 'Hard', 'Expert', 'Impossible'];\n    difficulties.forEach(diff => {\n      const button = this.uiElements[`diff_${diff}`] as Phaser.GameObjects.Rectangle;\n      button.setFillStyle(diff === this.aiDifficulty ? 0xff6b6b : 0x333333);\n    });\n  }\n  \n  private updateUI(): void {\n    // Update current player display\n    const playerText = this.gameMode === 'PvP' ? `Current Player: ${this.currentPlayer}` :\n                      this.gameMode === 'PvAI' ? (this.currentPlayer === 'X' ? 'Your Turn' : 'AI Thinking...') :\n                      this.gameMode === 'AIvAI' ? `AI ${this.currentPlayer} Turn` :\n                      'Tournament Mode';\n    \n    (this.uiElements.currentPlayerText as Phaser.GameObjects.Text).setText(playerText);\n  }\n  \n  private updateScoreDisplay(): void {\n    (this.uiElements.scoreX as Phaser.GameObjects.Text).setText(`X: ${this.scores.X}`);\n    (this.uiElements.scoreO as Phaser.GameObjects.Text).setText(`O: ${this.scores.O}`);\n    (this.uiElements.scoreDraw as Phaser.GameObjects.Text).setText(`Draws: ${this.scores.draws}`);\n  }\n  \n  private updatePerformanceDisplay(metrics: any): void {\n    if (this.showPerformanceMetrics) {\n      const text = [\n        `FPS: ${metrics.fps}`,\n        `Frame: ${metrics.frameTime}ms`,\n        `Memory: ${metrics.memoryUsage}MB`,\n        `Quality: ${metrics.qualityLevel}`,\n        `Mode: ${this.gameMode}`,\n        `AI: ${this.aiDifficulty}`\n      ].join('\\n');\n      \n      (this.uiElements.performanceText as Phaser.GameObjects.Text).setText(text);\n    }\n  }\n  \n  private getDifficultyValue(): number {\n    const values = { Easy: 1, Medium: 2, Hard: 3, Expert: 4, Impossible: 5 };\n    return values[this.aiDifficulty];\n  }\n  \n  private newGame(): void {\n    // Reset game state\n    this.board = [\n      [null, null, null],\n      [null, null, null],\n      [null, null, null]\n    ];\n    this.currentPlayer = 'X';\n    this.gameOver = false;\n    this.isProcessingMove = false;\n    this.moveHistory = [];\n    \n    // Clear visual elements\n    this.children.list.forEach(child => {\n      if (child instanceof Phaser.GameObjects.Text && child.text.match(/[XO]|Wins|Draw/)) {\n        child.destroy();\n      }\n    });\n    \n    // Clear highlights\n    this.cellHighlights.forEach(highlight => {\n      if (highlight) highlight.destroy();\n    });\n    this.cellHighlights = [];\n    \n    // Clear mark texts\n    this.markTexts.forEach(row => {\n      row.forEach(text => {\n        if (text) text.setVisible(false);\n      });\n    });\n    \n    // Reset AI\n    this.aiPlayer = new AdvancedAIPlayer('O', this.aiDifficulty);\n    \n    // Redraw board\n    this.drawBoard();\n    \n    // Animate board appearance\n    const cellPositions = [];\n    for (let row = 0; row < 3; row++) {\n      for (let col = 0; col < 3; col++) {\n        cellPositions.push({\n          x: this.boardStartX + col * this.cellSize + this.cellSize / 2,\n          y: this.boardStartY + row * this.cellSize + this.cellSize / 2\n        });\n      }\n    }\n    \n    this.gameFeelManager.animateGridAppearance(cellPositions, this.cellSize);\n    \n    // Update UI\n    this.updateUI();\n  }\n  \n  private startTournamentMode(): void {\n    // Simple tournament implementation - create a tournament with available AIs\n    const humanPlayer = this.tournamentSystem.addHumanPlayer('Human Player');\n    const aiPlayers = this.tournamentSystem.getAvailablePlayers().filter(p => p.type === 'AI');\n    \n    const tournamentPlayers = [humanPlayer.id, ...aiPlayers.slice(0, 3).map(p => p.id)];\n    \n    this.currentTournament = this.tournamentSystem.createTournament(\n      'Quick Tournament',\n      'SingleElimination',\n      tournamentPlayers\n    );\n    \n    this.tournamentSystem.startTournament(this.currentTournament.id);\n    \n    console.log('Tournament started:', this.currentTournament);\n    \n    // Show tournament UI (simplified)\n    this.add.text(WIDTH / 2, HEIGHT / 2, 'Tournament Mode\\n(Feature in development)', {\n      fontSize: '24px',\n      color: '#fbbf24',\n      align: 'center'\n    }).setOrigin(0.5);\n  }\n  \n  private handleTournamentResult(result: 'X' | 'O' | 'Draw'): void {\n    if (!this.currentTournament) return;\n    \n    // Simplified tournament result handling\n    console.log('Tournament result:', result);\n    \n    // Continue tournament or show results\n    // This would be expanded in a full implementation\n  }\n}\n\n// Game configuration with enhanced settings\nconst config: Phaser.Types.Core.GameConfig = {\n  type: Phaser.AUTO,\n  width: WIDTH,\n  height: HEIGHT,\n  parent: 'game',\n  backgroundColor: '#1a1a2e',\n  scene: EnhancedTicTacToeScene,\n  render: {\n    antialias: true,\n    pixelArt: false,\n    roundPixels: true\n  }\n};\n\nnew Phaser.Game(config);